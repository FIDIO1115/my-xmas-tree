<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Christmas Magic 2025</title>
    <link href="https://fonts.googleapis.com/css2?family=Great+Vibes&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; }
        
        /* 標題樣式修正：確保金色漸層與藝術字體顯示 */
        #main-title { 
            position: absolute; top: 40px; left: 0; width: 100%; text-align: center; 
            z-index: 999; pointer-events: none; opacity: 0; transition: opacity 1s ease; 
            font-family: 'Great Vibes', cursive; font-size: 6rem;
            background: linear-gradient(to bottom, #ffd700 20%, #fffacd 50%, #ffaa00 80%);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 0 20px rgba(255, 215, 0, 0.6));
        }

        #start-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: radial-gradient(circle, #001a00 0%, #000 100%); z-index: 2000; display: flex; flex-direction: column; justify-content: center; align-items: center; color: #fff; }
        #btn-start { padding: 18px 60px; font-size: 22px; background: linear-gradient(90deg, #ffd700, #ffaa00); border: none; border-radius: 40px; color: #000; font-weight: bold; cursor: pointer; box-shadow: 0 0 40px rgba(255, 215, 0, 0.4); margin-top: 30px; }
        
        #photo-modal { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%) scale(0.8); max-width: 80%; max-height: 80%; background: #fff; padding: 15px; box-shadow: 0 0 100px rgba(255,255,255,0.2); z-index: 1000; opacity: 0; pointer-events: none; transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275); border-radius: 12px; }
        #photo-modal.active { opacity: 1; transform: translate(-50%, -50%) scale(1); pointer-events: auto; }
        #photo-modal img { max-width: 100%; max-height: 65vh; display: block; border-radius: 4px; }
        
        #wish-wall { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); z-index: 1500; display: flex; flex-direction: column; align-items: center; justify-content: center; opacity: 0; pointer-events: none; transition: opacity 0.8s ease; backdrop-filter: blur(10px); }
        #wish-wall.active { opacity: 1; pointer-events: auto; }
        .wall-grid { display: grid; grid-template-columns: repeat(7, 1fr); gap: 10px; padding: 20px; max-width: 90vw; }
        .wall-grid img { width: 100%; aspect-ratio: 1/1; object-fit: cover; border-radius: 8px; border: 2px solid rgba(255,215,0,0.5); }
        #wish-text { font-family: 'Great Vibes', cursive; font-size: 5rem; color: #ffd700; text-shadow: 0 0 30px #ffd700; margin-bottom: 20px; text-align: center; }

        #input_video { position: absolute; bottom: 25px; left: 25px; width: 180px; height: 135px; border-radius: 15px; border: 2px solid rgba(255,255,255,0.2); transform: scaleX(-1); z-index: 100; object-fit: cover; opacity: 0.5; }
        .hint { position: absolute; bottom: 30px; width: 100%; text-align: center; color: rgba(255,255,255,0.6); font-size: 14px; pointer-events: none; z-index: 100; }
        
        @media (max-width: 600px) {
            #main-title { font-size: 3.5rem; top: 20px; }
            #wish-text { font-size: 3rem; }
            .wall-grid { grid-template-columns: repeat(4, 1fr); }
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>
    <div id="main-title">Merry Christmas</div>
    <div id="start-screen">
        <h1 style="font-family: 'Great Vibes'; font-size: 6rem; color: #ffd700; margin: 0;">Winter Magic</h1>
        <button id="btn-start">開啟聖誕魔法 ✨</button>
    </div>
    <div id="wish-wall">
        <div id="wish-text">祝你 聖誕快樂</div>
        <div class="wall-grid" id="wall-grid"></div>
    </div>
    <div class="hint">左手開：爆炸 | 右手捏：下一張 | 雙手合掌：聖誕祝福</div>
    <div id="photo-modal"><img id="modal-img" src=""></div>
    <video id="input_video"></video>

    <script type="x-shader/x-vertex" id="vertexshader">
        attribute float size; attribute vec3 customColor; attribute vec3 spherePos;
        varying vec3 vColor;
        uniform float uExplosion; uniform float uBeat;      
        void main() {
            vColor = customColor;
            float t = uExplosion;
            float ease = 1.0 - pow(1.0 - t, 3.0);
            vec3 finalPos = mix(position, spherePos, ease);
            vec4 mvPosition = modelViewMatrix * vec4(finalPos * (1.0 + uBeat * 0.12), 1.0);
            gl_PointSize = size * (400.0 / -mvPosition.z);
            gl_Position = projectionMatrix * mvPosition;
        }
    </script>
    <script type="x-shader/x-fragment" id="fragmentshader">
        uniform float uBeat; varying vec3 vColor;
        void main() {
            vec2 cxy = 2.0 * gl_PointCoord - 1.0;
            if (dot(cxy, cxy) > 1.0) discard;
            float glow = pow(1.0 - length(cxy), 2.0);
            gl_FragColor = vec4(vColor + (uBeat * 0.2), glow);
        }
    </script>

    <script>
        const PHOTO_COUNT = 31; // 修改為 31 張照片
        const state = { explosion: 0.0, targetExplosion: 0.0, photoActive: false, currentIndex: 0, pinchLocked: false, isWishActive: false };
        let scene, camera, renderer, clock, treeGroup, particleSystem, photoMeshes = [], loadedImages = [];
        let audioCtx, analyser, dataArray, audioEl;

        function createWall() {
            const grid = document.getElementById('wall-grid');
            grid.innerHTML = '';
            loadedImages.forEach(img => {
                if(img) {
                    const newImg = document.createElement('img');
                    newImg.src = img.src;
                    grid.appendChild(newImg);
                }
            });
        }

        function createCircularTexture(img) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const size = 512;
            canvas.width = size; canvas.height = size;
            ctx.beginPath(); ctx.arc(size/2, size/2, size/2, 0, Math.PI * 2); ctx.clip();
            const aspect = img.width / img.height;
            let nw, nh, nx, ny;
            if (aspect > 1) { nh = size; nw = size * aspect; ny = 0; nx = -(nw - size) / 2; }
            else { nw = size; nh = size / aspect; nx = 0; ny = -(nh - size) / 2; }
            ctx.drawImage(img, nx, ny, nw, nh);
            return new THREE.CanvasTexture(canvas);
        }

        async function autoLoadImages() {
            let loadedCount = 0;
            for (let i = 1; i <= PHOTO_COUNT; i++) {
                const img = new Image();
                img.crossOrigin = "anonymous";
                img.onload = () => {
                    loadedImages[i-1] = img;
                    loadedCount++;
                    if (loadedCount === PHOTO_COUNT) { updatePhotos(); createWall(); }
                };
                img.src = `${i}.jpg`;
                img.onerror = () => { 
                    loadedCount++; 
                    if (loadedCount === PHOTO_COUNT) { updatePhotos(); createWall(); } 
                };
            }
        }

        document.getElementById('btn-start').addEventListener('click', () => {
            document.getElementById('start-screen').style.display = 'none';
            document.getElementById('main-title').style.opacity = 1;
            initAudio(); initThree(); startHandTracking(); autoLoadImages();
        });

        function initAudio() {
            audioEl = new Audio("https://thirdparty.gtimg.com/C1000007bNrR1HXkjD.m4a?fromtag=38");
            audioEl.loop = true; audioEl.crossOrigin = "anonymous";
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioCtx.createAnalyser();
            const source = audioCtx.createMediaElementSource(audioEl);
            source.connect(analyser); analyser.connect(audioCtx.destination);
            dataArray = new Uint8Array(analyser.frequencyBinCount);
            audioEl.play().catch(e => console.log("音樂播放受阻，需使用者點擊按鈕"));
        }

        function initThree() {
            clock = new THREE.Clock(); scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.set(0, 30, 90);
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            treeGroup = new THREE.Group(); scene.add(treeGroup);
            createParticles(); animate();
        }

        function createParticles() {
            const count = 18000; const geo = new THREE.BufferGeometry();
            const pos = [], sph = [], col = [], siz = [];
            const colorHelper = new THREE.Color();
            for(let i=0; i<count; i++) {
                const y = (i/count) * 75; const r = (1 - y/75) * 30 * Math.sqrt(Math.random()); const a = i * 0.22;
                pos.push(Math.cos(a)*r, y - 10, Math.sin(a)*r);
                const v = new THREE.Vector3(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5).normalize().multiplyScalar(65);
                sph.push(v.x, v.y + 25, v.z);
                const rand = Math.random();
                if(rand > 0.9) colorHelper.setHex(0xffd700); 
                else if(rand > 0.8) colorHelper.setHex(0xffffff);
                else colorHelper.setHex(0x228b22);
                col.push(colorHelper.r, colorHelper.g, colorHelper.b);
                siz.push(Math.random() * 2 + 1.5);
            }
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            geo.setAttribute('spherePos', new THREE.Float32BufferAttribute(sph, 3));
            geo.setAttribute('customColor', new THREE.Float32BufferAttribute(col, 3));
            geo.setAttribute('size', new THREE.Float32BufferAttribute(siz, 1));
            particleSystem = new THREE.Points(geo, new THREE.ShaderMaterial({
                uniforms: { uExplosion: { value: 0 }, uBeat: { value: 0 } },
                vertexShader: document.getElementById('vertexshader').textContent,
                fragmentShader: document.getElementById('fragmentshader').textContent,
                blending: THREE.AdditiveBlending, transparent: true, depthTest: false
            }));
            treeGroup.add(particleSystem);
        }

        function updatePhotos() {
            photoMeshes.forEach(p => treeGroup.remove(p)); photoMeshes = [];
            for(let i=0; i<PHOTO_COUNT; i++) {
                if(!loadedImages[i]) continue;
                const tex = createCircularTexture(loadedImages[i]);
                const mesh = new THREE.Mesh(new THREE.SphereGeometry(3, 32, 32), new THREE.MeshBasicMaterial({ map: tex }));
                const y = Math.random() * 65; const r = (1 - y/75) * 32 + 2; const a = Math.random() * Math.PI * 2;
                mesh.position.set(Math.cos(a)*r, y-10, Math.sin(a)*r);
                treeGroup.add(mesh); photoMeshes.push(mesh);
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            if(analyser) { analyser.getByteFrequencyData(dataArray); particleSystem.material.uniforms.uBeat.value = dataArray[10]/255; }
            state.explosion += (state.targetExplosion - state.explosion) * 0.1;
            particleSystem.material.uniforms.uExplosion.value = state.explosion;
            treeGroup.rotation.y += 0.005;
            photoMeshes.forEach(p => p.lookAt(camera.position));
            renderer.render(scene, camera);
        }

        function startHandTracking() {
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.75, minTrackingConfidence: 0.5 });
            
            hands.onResults(results => {
                let rightVisible = false, leftVisible = false, hL = null, hR = null;
                if (results.multiHandLandmarks) {
                    results.multiHandLandmarks.forEach((lm, index) => {
                        const label = results.multiHandedness[index].label;
                        if (label === 'Left') { hL = lm; leftVisible = true; } else { hR = lm; rightVisible = true; }
                    });
                }
                if (leftVisible && rightVisible) {
                    const dist = Math.hypot(hL[9].x - hR[9].x, hL[9].y - hR[9].y);
                    if (dist < 0.1) { document.getElementById('wish-wall').classList.add('active'); state.isWishActive = true; }
                    else { document.getElementById('wish-wall').classList.remove('active'); state.isWishActive = false; }
                } else { document.getElementById('wish-wall').classList.remove('active'); state.isWishActive = false; }

                if (leftVisible && !state.isWishActive) {
                    const d = Math.hypot(hL[8].x - hL[20].x, hL[8].y - hL[20].y);
                    state.targetExplosion = d > 0.45 ? 1 : 0;
                } else { state.targetExplosion = 0; }

                if (rightVisible && !state.isWishActive) {
                    const pinch = Math.hypot(hR[4].x - hR[8].x, hR[4].y - hR[8].y);
                    if (pinch < 0.045) {
                        if (!state.pinchLocked) { state.currentIndex = (state.currentIndex + 1) % PHOTO_COUNT; updateModal(); state.pinchLocked = true; }
                    } else { state.pinchLocked = false; }
                } else { document.getElementById('photo-modal').classList.remove('active'); }
            });

            new Camera(document.getElementById('input_video'), {
                onFrame: async () => { await hands.send({image: document.getElementById('input_video')}); },
                width: 320, height: 240
            }).start();
        }

        function updateModal() {
            if(loadedImages[state.currentIndex]) {
                document.getElementById('modal-img').src = loadedImages[state.currentIndex].src;
                document.getElementById('photo-modal').classList.add('active');
            }
        }
    </script>
</body>
</html>